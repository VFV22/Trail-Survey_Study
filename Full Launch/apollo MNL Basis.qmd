---
title: "index"
format: html
editor: visual
---

```{r}
library(apollo)

apollo_initialise()

```

# MNL - RUM For All Respondents

Here need to make the data into wide format to create the utility functions.

```{r}
#after running Analysis


mlogit_clean=mlogit_clean[c(1:11,15,19,38:47, 71)]
mlogit_clean$Alternative[which(mlogit_clean$Alternative==1)]="alt1"
mlogit_clean$Alternative[which(mlogit_clean$Alternative=="2")]="alt2"
mlogit_clean$Alternative[which(mlogit_clean$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_wide=reshape(mlogit_clean,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternative’s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)


#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

## MNL - Apollo code

b_HHIncome_num = 0,

```{r}

apollo_beta <- c(
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow        = 0,
  b_cost                = 0,
  b_resident            = 0,
  b_age                 = 0,
  b_education           = 0,
  #b_environment = 0, 
  #b_userfee = 0, 
  b_income              = 0, 
  b_sex = 0
)
apollo_fixed <- c()


apollo_inputs<-apollo_validateInputs()
```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1
  V[["alt1"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt1 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt1 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt1 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt1 +
    b_CrowdingMed         * CrowdingM.alt1 +
    b_CrowdingLow         * CrowdingL.alt1 +
    b_cost                * Cost.alt1 +
    
    # person-specific covariates (shift alt1 vs opt-out)
    b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
    #b_environment* Member.Environment_binary +
    #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Utility for alt2
  V[["alt2"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt2 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt2 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt2 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt2 +
    b_CrowdingMed         * CrowdingM.alt2 +
    b_CrowdingLow         * CrowdingL.alt2 +
    b_cost                * Cost.alt2 +
    
    # person-specific covariates (shift alt2 vs opt-out)
    b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
    #b_environment* Member.Environment_binary +
   #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
  P[["model"]] = apollo_mnl(mnl_settings, functionality)
  P = apollo_panelProd(P, apollo_inputs, functionality)
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  
  return(P)
}

```

```{r}
model = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

summary(model)
```

```{r}

#Extract apollo model result 
est <- model$estimate

#Extract standard error
se <- sqrt(diag(model$robvarcov))

#Create coefficient table 
coef_table <- tibble(
  Parameter = names(est),
  Estimate  = est,
  SE        = se[names(est)]
)

#Add significance stars
coef_table <- coef_table %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )

```

# RUM For Trails (Residents Only)

Here need to make the data into wide format to create the utility functions.

```{r}
#after running Analysis


mlogit_clean_Residents=mlogit_clean_Residents[c(1:11,15,19,38:47, 71)]
mlogit_clean_Residents$Alternative[which(mlogit_clean_Residents$Alternative==1)]="alt1"
mlogit_clean_Residents$Alternative[which(mlogit_clean_Residents$Alternative=="2")]="alt2"
mlogit_clean_Residents$Alternative[which(mlogit_clean_Residents$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_Residents_wide=reshape(mlogit_clean_Residents,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternative’s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_Residents_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)

#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

## MNL Resident - Apollo code

b_HHIncome_num = 0,

```{r}
apollo_beta <- c(
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow        = 0,
  b_cost                = 0,
  b_age                 = 0,
  b_education           = 0,
  #b_environment = 0, 
  b_income              = 0, 
  b_sex = 0
)
apollo_fixed <- c()


apollo_inputs<-apollo_validateInputs()
```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1
  V[["alt1"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt1 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt1 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt1 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt1 +
    b_CrowdingMed         * CrowdingM.alt1 +
    b_CrowdingLow         * CrowdingL.alt1 +
    b_cost                * Cost.alt1 +
    
    # person-specific covariates (shift alt1 vs opt-out)
    #b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
   #b_environment* Member.Environment_binary +
    #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Utility for alt2
  V[["alt2"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt2 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt2 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt2 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt2 +
    b_CrowdingMed         * CrowdingM.alt2 +
    b_CrowdingLow         * CrowdingL.alt2 +
    b_cost                * Cost.alt2 +
    
    # person-specific covariates (shift alt2 vs opt-out)
   # b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
    #b_environment* Member.Environment_binary +
   #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
  P[["model"]] = apollo_mnl(mnl_settings, functionality)
  P = apollo_panelProd(P, apollo_inputs, functionality)
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  
  return(P)
}
```

```{r}
model_residents = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

summary(model_residents)
```

```{r}

# Extract Apollo model results
est.residents <- model_residents$estimate

# Extract standard errors
se.residents <- sqrt(diag(model_residents$robvarcov))

# Create coefficient table
coef_residents <- tibble(
  Parameter = names(est.residents),
  Estimate  = est.residents,
  SE        = se.residents[names(est.residents)]
)

# Add significance stars
coef_residents <- coef_residents %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )

```

# RUM For Trails (Tourists Only)

Here need to make the data into wide format to create the utility functions.

```{r}
#after running Analysis

mlogit_clean_Tourists=mlogit_clean_Tourists[c(1:11,15,19,38:47, 71)]
mlogit_clean_Tourists$Alternative[which(mlogit_clean_Tourists$Alternative==1)]="alt1"
mlogit_clean_Tourists$Alternative[which(mlogit_clean_Tourists$Alternative=="2")]="alt2"
mlogit_clean_Tourists$Alternative[which(mlogit_clean_Tourists$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_Tourists_wide=reshape(mlogit_clean_Tourists,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternative’s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_Tourists_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)


#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

## MNL Tourist Apollo code

b_HHIncome_num = 0,

```{r}

apollo_beta <- c(
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow        = 0,
  b_cost                = 0,
  b_age                 = 0,
  b_education           = 0,
  #b_environment = 0, 
  b_income              = 0, 
  b_sex = 0
)
apollo_fixed <- c()


apollo_inputs<-apollo_validateInputs()
```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1
  V[["alt1"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt1 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt1 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt1 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt1 +
    b_CrowdingMed         * CrowdingM.alt1 +
    b_CrowdingLow         * CrowdingL.alt1 +
    b_cost                * Cost.alt1 +
    
    # person-specific covariates (shift alt1 vs opt-out)
    #b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
   #b_environment* Member.Environment_binary +
    #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Utility for alt2
  V[["alt2"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt2 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt2 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt2 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt2 +
    b_CrowdingMed         * CrowdingM.alt2 +
    b_CrowdingLow         * CrowdingL.alt2 +
    b_cost                * Cost.alt2 +
    
    # person-specific covariates (shift alt2 vs opt-out)
   # b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
    #b_environment* Member.Environment_binary +
   #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
  P[["model"]] = apollo_mnl(mnl_settings, functionality)
  P = apollo_panelProd(P, apollo_inputs, functionality)
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  
  return(P)
}
```

```{r}
model_tourists = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

summary(model_tourists)
```

```{r}

# Extract Apollo model results
est.tourists <- model_tourists$estimate

# Extract standard errors
se.tourists<- sqrt(diag(model_tourists$robvarcov))

# Create coefficient table
coef_tourists <- tibble(
  Parameter = names(est.tourists),
  Estimate  = est.tourists,
  SE        = se.residents[names(est.tourists)]
)

# Add significance stars
coef_tourists <- coef_tourists%>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )

```

# MXL For All Respondents

Here need to make the data into wide format to create the utility functions.

```{r}
database=mlogit_clean_wide
```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)


#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

```{r}
apollo_inputs <- apollo_validateInputs()
```

## MXL - Apollo code

```{r}
apollo_beta <- c(
  # means
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow         = 0,
  b_cost                = 0,

  # sociodems (fixed)
  b_resident  = 0,
  b_age       = 0,
  b_education = 0,
  b_income    = 0,
  b_sex       = 0,

  # SDs for random coeffs (start close to zero but allow heterogeneity to grow if the data support it)
  sd_Habitat_QualityMed  = 0.1,
  sd_Habitat_QualityHigh = 0.1,
  sd_Trail_ConditionMed  = 0.1,
  sd_Trail_ConditionHigh = 0.1,
  sd_CrowdingMed         = 0.1,
  sd_CrowdingLow         = 0.1
)
apollo_fixed <- c()

```

```{r}
apollo_draws <- list(
  interDrawsType = "halton",
  interNDraws    = 500,     # start with 200–500; increase later
  interNormDraws = c(
    "draw_Habitat_QualityMed",
    "draw_Habitat_QualityHigh",
    "draw_Trail_ConditionMed",
    "draw_Trail_ConditionHigh",
    "draw_CrowdingMed",
    "draw_CrowdingLow"
  )
)

apollo_randCoeff <- function(apollo_beta, apollo_inputs){

  randcoeff <- list()

  randcoeff[["b_Habitat_QualityMed_R"]]  <- b_Habitat_QualityMed +
    sd_Habitat_QualityMed * draw_Habitat_QualityMed

  randcoeff[["b_Habitat_QualityHigh_R"]] <- b_Habitat_QualityHigh +
    sd_Habitat_QualityHigh * draw_Habitat_QualityHigh

  randcoeff[["b_Trail_ConditionMed_R"]]  <- b_Trail_ConditionMed +
    sd_Trail_ConditionMed * draw_Trail_ConditionMed

  randcoeff[["b_Trail_ConditionHigh_R"]] <- b_Trail_ConditionHigh +
    sd_Trail_ConditionHigh * draw_Trail_ConditionHigh

  randcoeff[["b_CrowdingMed_R"]] <- b_CrowdingMed +
    sd_CrowdingMed * draw_CrowdingMed

  randcoeff[["b_CrowdingLow_R"]] <- b_CrowdingLow +
    sd_CrowdingLow * draw_CrowdingLow

  return(randcoeff)
}

```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1

V[["alt1"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt1 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt1 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt1 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt1 +
  b_CrowdingMed_R         * CrowdingM.alt1 +
  b_CrowdingLow_R         * CrowdingL.alt1 +
  b_cost                  * Cost.alt1 +
  b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary

  
  # Utility for alt2
  V[["alt2"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt2 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt2 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt2 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt2 +
  b_CrowdingMed_R         * CrowdingM.alt2 +
  b_CrowdingLow_R         * CrowdingL.alt2 +
  b_cost                  * Cost.alt2 +
  b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
P[["model"]] = apollo_mnl(mnl_settings, functionality)

P = apollo_panelProd(P, apollo_inputs, functionality)

P = apollo_avgInterDraws(P, apollo_inputs, functionality)  # <-- mixed logit integration  

P = apollo_prepareProb(P, apollo_inputs, functionality)

  
  return(P)
}

```

```{r}
model_mxl <- apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)
summary(model_mxl)
```

```{r}

#Extract apollo model result 
est <- model_mxl$estimate

#Extract standard error
se <- sqrt(diag(model_mxl$robvarcov))

#Create coefficient table 
coef_table <- tibble(
  Parameter = names(est),
  Estimate  = est,
  SE        = se[names(est)]
)

#Add significance stars
MXL_coef_table <- coef_table %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )
```

# MXL For Trails (Residents Only)

Here need to make the data into wide format to create the utility functions.

```{r}
database=mlogit_clean_Residents_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)

#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

```{r}
apollo_inputs <- apollo_validateInputs()
```

## MXL - Apollo code

```{r}
apollo_beta <- c(
  # means
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow         = 0,
  b_cost                = 0,

  # sociodems (fixed)
  #b_resident  = 0,
  b_age       = 0,
  b_education = 0,
  b_income    = 0,
  b_sex       = 0,

  # SDs for random coeffs (start close to zero but allow heterogeneity to grow if the data support it)
  sd_Habitat_QualityMed  = 0.1,
  sd_Habitat_QualityHigh = 0.1,
  sd_Trail_ConditionMed  = 0.1,
  sd_Trail_ConditionHigh = 0.1,
  sd_CrowdingMed         = 0.1,
  sd_CrowdingLow         = 0.1
)
apollo_fixed <- c()

```

```{r}
apollo_draws <- list(
  interDrawsType = "halton",
  interNDraws    = 500,     # start with 200–500; increase later
  interNormDraws = c(
    "draw_Habitat_QualityMed",
    "draw_Habitat_QualityHigh",
    "draw_Trail_ConditionMed",
    "draw_Trail_ConditionHigh",
    "draw_CrowdingMed",
    "draw_CrowdingLow"
  )
)

apollo_randCoeff <- function(apollo_beta, apollo_inputs){

  randcoeff <- list()

  randcoeff[["b_Habitat_QualityMed_R"]]  <- b_Habitat_QualityMed +
    sd_Habitat_QualityMed * draw_Habitat_QualityMed

  randcoeff[["b_Habitat_QualityHigh_R"]] <- b_Habitat_QualityHigh +
    sd_Habitat_QualityHigh * draw_Habitat_QualityHigh

  randcoeff[["b_Trail_ConditionMed_R"]]  <- b_Trail_ConditionMed +
    sd_Trail_ConditionMed * draw_Trail_ConditionMed

  randcoeff[["b_Trail_ConditionHigh_R"]] <- b_Trail_ConditionHigh +
    sd_Trail_ConditionHigh * draw_Trail_ConditionHigh

  randcoeff[["b_CrowdingMed_R"]] <- b_CrowdingMed +
    sd_CrowdingMed * draw_CrowdingMed

  randcoeff[["b_CrowdingLow_R"]] <- b_CrowdingLow +
    sd_CrowdingLow * draw_CrowdingLow

  return(randcoeff)
}

```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1

V[["alt1"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt1 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt1 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt1 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt1 +
  b_CrowdingMed_R         * CrowdingM.alt1 +
  b_CrowdingLow_R         * CrowdingL.alt1 +
  b_cost                  * Cost.alt1 +
  #b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary

  
  # Utility for alt2
  V[["alt2"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt2 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt2 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt2 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt2 +
  b_CrowdingMed_R         * CrowdingM.alt2 +
  b_CrowdingLow_R         * CrowdingL.alt2 +
  b_cost                  * Cost.alt2 +
  #b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
P[["model"]] = apollo_mnl(mnl_settings, functionality)

P = apollo_panelProd(P, apollo_inputs, functionality)

P = apollo_avgInterDraws(P, apollo_inputs, functionality)  # <-- mixed logit integration  

P = apollo_prepareProb(P, apollo_inputs, functionality)

  
  return(P)
}

```

```{r}
model_mxl_Resident <- apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)
summary(model_mxl_Resident)
```

```{r}

#Extract apollo model result 
est <- model_mxl_Resident$estimate

#Extract standard error
se <- sqrt(diag(model_mxl_Resident$robvarcov))

#Create coefficient table 
coef_table <- tibble(
  Parameter = names(est),
  Estimate  = est,
  SE        = se[names(est)]
)

#Add significance stars
MXL_coef_table_Resident <- coef_table %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )
```

# MXL For Trails (Tourist Only)

Here need to make the data into wide format to create the utility functions.

```{r}
database=mlogit_clean_Tourists_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)

#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

```{r}
apollo_inputs <- apollo_validateInputs()
```

## MXL - Apollo code

```{r}
apollo_beta <- c(
  # means
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow         = 0,
  b_cost                = 0,

  # sociodems (fixed)
  #b_resident  = 0,
  b_age       = 0,
  b_education = 0,
  b_income    = 0,
  b_sex       = 0,

  # SDs for random coeffs (start close to zero but allow heterogeneity to grow if the data support it)
  sd_Habitat_QualityMed  = 0.1,
  sd_Habitat_QualityHigh = 0.1,
  sd_Trail_ConditionMed  = 0.1,
  sd_Trail_ConditionHigh = 0.1,
  sd_CrowdingMed         = 0.1,
  sd_CrowdingLow         = 0.1
)
apollo_fixed <- c()

```

```{r}
apollo_draws <- list(
  interDrawsType = "halton",
  interNDraws    = 500,     # start with 200–500; increase later
  interNormDraws = c(
    "draw_Habitat_QualityMed",
    "draw_Habitat_QualityHigh",
    "draw_Trail_ConditionMed",
    "draw_Trail_ConditionHigh",
    "draw_CrowdingMed",
    "draw_CrowdingLow"
  )
)

apollo_randCoeff <- function(apollo_beta, apollo_inputs){

  randcoeff <- list()

  randcoeff[["b_Habitat_QualityMed_R"]]  <- b_Habitat_QualityMed +
    sd_Habitat_QualityMed * draw_Habitat_QualityMed

  randcoeff[["b_Habitat_QualityHigh_R"]] <- b_Habitat_QualityHigh +
    sd_Habitat_QualityHigh * draw_Habitat_QualityHigh

  randcoeff[["b_Trail_ConditionMed_R"]]  <- b_Trail_ConditionMed +
    sd_Trail_ConditionMed * draw_Trail_ConditionMed

  randcoeff[["b_Trail_ConditionHigh_R"]] <- b_Trail_ConditionHigh +
    sd_Trail_ConditionHigh * draw_Trail_ConditionHigh

  randcoeff[["b_CrowdingMed_R"]] <- b_CrowdingMed +
    sd_CrowdingMed * draw_CrowdingMed

  randcoeff[["b_CrowdingLow_R"]] <- b_CrowdingLow +
    sd_CrowdingLow * draw_CrowdingLow

  return(randcoeff)
}

```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1

V[["alt1"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt1 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt1 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt1 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt1 +
  b_CrowdingMed_R         * CrowdingM.alt1 +
  b_CrowdingLow_R         * CrowdingL.alt1 +
  b_cost                  * Cost.alt1 +
  #b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary

  
  # Utility for alt2
  V[["alt2"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt2 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt2 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt2 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt2 +
  b_CrowdingMed_R         * CrowdingM.alt2 +
  b_CrowdingLow_R         * CrowdingL.alt2 +
  b_cost                  * Cost.alt2 +
  #b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
P[["model"]] = apollo_mnl(mnl_settings, functionality)

P = apollo_panelProd(P, apollo_inputs, functionality)

P = apollo_avgInterDraws(P, apollo_inputs, functionality)  # <-- mixed logit integration  

P = apollo_prepareProb(P, apollo_inputs, functionality)

  
  return(P)
}

```

```{r}
model_mxl_Tourist <- apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)
summary(model_mxl_Tourist)
```

```{r}

#Extract apollo model result 
est <- model_mxl_Tourist$estimate

#Extract standard error
se <- sqrt(diag(model_mxl_Tourist$robvarcov))

#Create coefficient table 
coef_table <- tibble(
  Parameter = names(est),
  Estimate  = est,
  SE        = se[names(est)]
)

#Add significance stars
MXL_coef_table_Tourist <- coef_table %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )
```

# **Create Utility Table: Combine output: Stargazer**

```{r}
get_apollo_stargazer_inputs <- function(model, robust = TRUE, p_sided = 2) {
  M <- as.matrix(apollo_modelOutput(model, modelOutput_settings = list(silent = TRUE)))

  b <- M[, "Estimate"]

  if (robust) {
    se <- M[, "Rob.s.e."]
    t  <- M[, "Rob.t.rat.(0)"]
  } else {
    se <- M[, "s.e."]
    t  <- M[, "t.rat.(0)"]
  }

  # p-values from t-ratio (normal approximation)
  if (p_sided == 1) {
    p <- 1 - pnorm(abs(t))             # 1-sided
  } else {
    p <- 2 * (1 - pnorm(abs(t)))       # 2-sided
  }

  names(b)  <- rownames(M)
  names(se) <- rownames(M)
  names(p)  <- rownames(M)

  list(b = b, se = se, p = p)
}

align_to <- function(x, order) {
  out <- rep(NA_real_, length(order))
  names(out) <- order
  out[names(x)] <- x
  out
}

make_dummy_lm_named <- function(coef_names, n = 100, seed = 1) {
  set.seed(seed)
  K <- length(coef_names)
  X <- as.data.frame(matrix(rnorm(n * K), nrow = n, ncol = K))
  names(X) <- coef_names
  X$y <- rnorm(n)
  lm(y ~ 0 + ., data = X)  # no intercept
}
```

```{r}
library(stargazer)

# Extract
v_MNL_all  <- get_apollo_stargazer_inputs(model,      robust = TRUE, p_sided = 2)
v_MNL_res  <- get_apollo_stargazer_inputs(model_residents, robust = TRUE, p_sided = 2)
v_MNL_tour <- get_apollo_stargazer_inputs(model_tourists,  robust = TRUE, p_sided = 2)
v_MXL_all  <- get_apollo_stargazer_inputs(model_mxl,      robust = TRUE, p_sided = 2)
v_MXL_res  <- get_apollo_stargazer_inputs(model_mxl_Resident, robust = TRUE, p_sided = 2)
v_MXL_tour <- get_apollo_stargazer_inputs(model_mxl_Tourist,  robust = TRUE, p_sided = 2)

# Choose your row order (edit if needed)
order <- c(
  "b_Habitat_QualityMed","b_Habitat_QualityHigh",
  "b_Trail_ConditionMed","b_Trail_ConditionHigh",
  "b_CrowdingMed","b_CrowdingLow",
  "b_cost",
  "b_resident",
  "b_age","b_education","b_income","b_sex",


  "sd_Habitat_QualityMed","sd_Habitat_QualityHigh",
  "sd_Trail_ConditionMed","sd_Trail_ConditionHigh",
  "sd_CrowdingMed","sd_CrowdingLow"
)


labels <- c(
  "Habitat quality (Medium)","Habitat quality (High)",
  "Trail condition (Medium)","Trail condition (High)",
  "Crowding (Medium)","Crowding (Low)",
  "Cost",
  "Resident",
  "Age","Education","Income","Sex",
  "SD: Habitat quality (Medium)","SD: Habitat quality (High)",
  "SD: Trail condition (Medium)","SD: Trail condition (High)",
  "SD: Crowding (Medium)","SD: Crowding (Low)"
)


# Align each model’s vectors to the same coefficient list
coef_list <- list(
  align_to(v_MNL_all$b,  order),
  align_to(v_MNL_res$b,  order),
  align_to(v_MNL_tour$b, order),
  align_to(v_MXL_all$b,  order),
  align_to(v_MXL_res$b,  order),
  align_to(v_MXL_tour$b, order)
)

se_list <- list(
  align_to(v_MNL_all$se,  order),
  align_to(v_MNL_res$se,  order),
  align_to(v_MNL_tour$se, order),
  align_to(v_MXL_all$se,  order),
  align_to(v_MXL_res$se,  order),
  align_to(v_MXL_tour$se, order)
)

p_list <- list(
  align_to(v_MNL_all$p,  order),
  align_to(v_MNL_res$p,  order),
  align_to(v_MNL_tour$p, order),
  align_to(v_MXL_all$p,  order),
  align_to(v_MXL_res$p,  order),
  align_to(v_MXL_tour$p, order)
)

# Dummy models for stargazer
make_dummy_lm_named <- function(coef_names, n = 100, seed = 1) {
  set.seed(seed)
  K <- length(coef_names)
  X <- as.data.frame(matrix(rnorm(n * K), nrow = n, ncol = K))
  names(X) <- coef_names
  X$y <- rnorm(n)
  lm(y ~ 0 + ., data = X)  # no intercept, so exactly K coefs with these names
}

d1 <- make_dummy_lm_named(order, seed = 1)
d2 <- make_dummy_lm_named(order, seed = 2)
d3 <- make_dummy_lm_named(order, seed = 3)
d4 <- make_dummy_lm_named(order, seed = 4)
d5 <- make_dummy_lm_named(order, seed = 5)
d6 <- make_dummy_lm_named(order, seed = 6)



```

```{r}
obs <- c(model$nObs, model_residents$nObs, model_tourists$nObs,
         model_mxl$nObs, model_mxl_Resident$nObs, model_mxl_Tourist$nObs)

resp <- c(model$nIndivs, model_residents$nIndivs, model_tourists$nIndivs,
          model_mxl$nIndivs, model_mxl_Resident$nIndivs, model_mxl_Tourist$nIndivs)

aic <- round(c(model$AIC, model_residents$AIC, model_tourists$AIC,
               model_mxl$AIC, model_mxl_Resident$AIC, model_mxl_Tourist$AIC), 2)


```

```{r}
stargazer(
  d1, d2, d3,
  type = "latex",
  out  = "mxl_3models.tex",
  title = "Trail Choice Model Results",
  column.labels = c("All Respondents", "Residents only", "Tourists only"),
  dep.var.labels.include = FALSE,
  covariate.labels = labels,
  coef = coef_list,
  se   = se_list,
  p    = p_list,
  digits = 3,
  omit.stat = c("n","f","ser","adj.rsq","rsq"),
  add.lines = list(
    c("Observations", obs),
    c("Respondents", respondents),
    c("AIC", aic)
  ),
  notes = "Robust standard errors in parentheses.",
  notes.append = FALSE
)



```

```{r}
library(stargazer)

stargazer(
  d1, d2, d3, d4, d5, d6,
  type = "html",
  out  = "Mnl_Mxl_table.html",
  title = "Trail Choice Model Results",

  column.labels   = c("MNL", "MXL"),
  column.separate = c(3, 3),

  model.numbers = TRUE,            # shows (1)-(6)
  dep.var.labels.include = FALSE,

  covariate.labels = labels,
  coef = coef_list, se = se_list, p = p_list,
  omit.stat = c("n","f","ser","adj.rsq","rsq"),
  add.lines = list(
    c("Observations", obs),
    c("Respondents",  resp),
    c("AIC",          aic)
  ),
  notes = "Columns (1)-(3): All / Residents / Tourists (MNL). Columns (4)-(6): All / Residents / Tourists (MXL). SE in parentheses.",
  notes.append = FALSE
)




```
