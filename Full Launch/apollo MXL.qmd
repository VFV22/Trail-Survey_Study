---
title: "index"
format: html
editor: visual
---

```{r}
packageVersion("apollo")
ls("package:apollo")


```

## RUM For All Respondents

Here need to make the data into wide format to create the utility functions.

```{r}
#after running Analysis


mlogit_clean=mlogit_clean[c(1:11,15,19,38:47, 71)]
mlogit_clean$Alternative[which(mlogit_clean$Alternative==1)]="alt1"
mlogit_clean$Alternative[which(mlogit_clean$Alternative=="2")]="alt2"
mlogit_clean$Alternative[which(mlogit_clean$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_wide=reshape(mlogit_clean,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternative’s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_wide

```

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAaCAYAAADFTB7LAAAAcElEQVR4Xu3OwQmAQAxE0bClWYCW5N06tM6V2YPg5CjoF/JhLoHAi6iqn9eOefUbqrYvHY0cQDLyAlKRNyARmYA0ZMLRkAlGQyaU72tkAtlim7r/vJqDUDjlKBROOQyFU2icQuMUGqfQuBEaV1XPOwEx96nYACK8+wAAAABJRU5ErkJggg== "Run Current Chunk")

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)


#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

```{r}
apollo_inputs <- apollo_validateInputs()
```

# Apollo code

b_HHIncome_num = 0,

```{r}

apollo_beta <- c(
  # means
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow         = 0,
  b_cost                = 0,

  # sociodems (fixed)
  b_resident  = 0,
  b_age       = 0,
  b_education = 0,
  b_income    = 0,
  b_sex       = 0,

  # SDs for random coeffs (start close to zero but allow heterogeneity to grow if the data support it)
  sd_Habitat_QualityMed  = 0.1,
  sd_Habitat_QualityHigh = 0.1,
  sd_Trail_ConditionMed  = 0.1,
  sd_Trail_ConditionHigh = 0.1,
  sd_CrowdingMed         = 0.1,
  sd_CrowdingLow         = 0.1
)
apollo_fixed <- c()

```

```{r}
apollo_draws <- list(
  interDrawsType = "halton",
  interNDraws    = 500,     # start with 200–500; increase later
  interNormDraws = c(
    "draw_Habitat_QualityMed",
    "draw_Habitat_QualityHigh",
    "draw_Trail_ConditionMed",
    "draw_Trail_ConditionHigh",
    "draw_CrowdingMed",
    "draw_CrowdingLow"
  )
)

apollo_randCoeff <- function(apollo_beta, apollo_inputs){

  randcoeff <- list()

  randcoeff[["b_Habitat_QualityMed_R"]]  <- b_Habitat_QualityMed +
    sd_Habitat_QualityMed * draw_Habitat_QualityMed

  randcoeff[["b_Habitat_QualityHigh_R"]] <- b_Habitat_QualityHigh +
    sd_Habitat_QualityHigh * draw_Habitat_QualityHigh

  randcoeff[["b_Trail_ConditionMed_R"]]  <- b_Trail_ConditionMed +
    sd_Trail_ConditionMed * draw_Trail_ConditionMed

  randcoeff[["b_Trail_ConditionHigh_R"]] <- b_Trail_ConditionHigh +
    sd_Trail_ConditionHigh * draw_Trail_ConditionHigh

  randcoeff[["b_CrowdingMed_R"]] <- b_CrowdingMed +
    sd_CrowdingMed * draw_CrowdingMed

  randcoeff[["b_CrowdingLow_R"]] <- b_CrowdingLow +
    sd_CrowdingLow * draw_CrowdingLow

  return(randcoeff)
}

```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1

V[["alt1"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt1 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt1 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt1 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt1 +
  b_CrowdingMed_R         * CrowdingM.alt1 +
  b_CrowdingLow_R         * CrowdingL.alt1 +
  b_cost                  * Cost.alt1 +
  b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary

  
  # Utility for alt2
  V[["alt2"]]  =
  b_Habitat_QualityMed_R  * Habitat_QualityM.alt2 +
  b_Habitat_QualityHigh_R * Habitat_QualityH.alt2 +
  b_Trail_ConditionMed_R  * Trail_ConditionM.alt2 +
  b_Trail_ConditionHigh_R * Trail_ConditionH.alt2 +
  b_CrowdingMed_R         * CrowdingM.alt2 +
  b_CrowdingLow_R         * CrowdingL.alt2 +
  b_cost                  * Cost.alt2 +
  b_resident   * Resident +
  b_age        * Demo_Age_num +
  b_education  * CollegePlus +
  b_income     * HHIncome_num +
  b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
P[["model"]] = apollo_mnl(mnl_settings, functionality)

P = apollo_panelProd(P, apollo_inputs, functionality)

P = apollo_avgInterDraws(P, apollo_inputs, functionality)  # <-- mixed logit integration  

P = apollo_prepareProb(P, apollo_inputs, functionality)

  
  return(P)
}

```

```{r}
model_mxl <- apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)
summary(model_mxl)

```

```{r}
# model_mxl is your fitted Apollo model
bhat <- model_mxl$estimate

# check names
names(bhat)
```

```{r}
rand_attrs <- c(
  "b_Habitat_QualityMed",
  "b_Habitat_QualityHigh",
  "b_Trail_ConditionMed",
  "b_Trail_ConditionHigh",
  "b_CrowdingMed",
  "b_CrowdingLow"
)

sd_names <- c(
  "sd_Habitat_QualityMed",
  "sd_Habitat_QualityHigh",
  "sd_Trail_ConditionMed",
  "sd_Trail_ConditionHigh",
  "sd_CrowdingMed",
  "sd_CrowdingLow"
)

cost_name <- "b_cost"

```

```{r}
simulate_population_wtp <- function(model_mxl,
                                    rand_attrs,
                                    sd_names,
                                    cost_name = "b_cost",
                                    n_draws = 10000) {

  bhat <- model_mxl$estimate

  # --- explicit numeric extraction (prevents NULL/character issues)
  mu <- setNames(as.numeric(bhat[rand_attrs]), rand_attrs)
  sd <- setNames(as.numeric(bhat[sd_names]),  rand_attrs)  # name SDs to match attrs
  b_cost <- as.numeric(bhat[cost_name])

  # safety checks
  if (any(is.na(mu))) stop("Some rand_attrs were not found in model estimates: ", paste(rand_attrs[is.na(mu)], collapse=", "))
  if (any(is.na(sd))) stop("Some sd_names were not found in model estimates.")
  if (is.na(b_cost)) stop("Cost coefficient not found: ", cost_name)

  K <- length(rand_attrs)

  # draws
  Z <- matrix(rnorm(n_draws * K), nrow = n_draws, ncol = K)
  colnames(Z) <- rand_attrs

  # beta draws: mu + sd * z
  beta_mat <- sweep(Z, 2, sd, `*`)
  beta_mat <- sweep(beta_mat, 2, mu, `+`)

  # WTP draws: -beta / b_cost
  wtp_mat <- -beta_mat / b_cost

  as_tibble(wtp_mat) %>%
    pivot_longer(cols = all_of(rand_attrs),
                 names_to = "Attribute",
                 values_to = "wtp")
}
```

```{r}
wtp_pop_draws <- simulate_population_wtp(
  model_mxl = model_mxl,
  rand_attrs = c("b_Habitat_QualityMed","b_Habitat_QualityHigh",
                 "b_Trail_ConditionMed","b_Trail_ConditionHigh",
                 "b_CrowdingMed","b_CrowdingLow"),
  sd_names   = c("sd_Habitat_QualityMed","sd_Habitat_QualityHigh",
                 "sd_Trail_ConditionMed","sd_Trail_ConditionHigh",
                 "sd_CrowdingMed","sd_CrowdingLow"),
  cost_name = "b_cost",
  n_draws = 10000
)


```

```{r}
wtp_pop_summary <- wtp_pop_draws %>%
  group_by(Attribute) %>%
  summarise(
    mean   = mean(wtp, na.rm = TRUE),
    median = median(wtp, na.rm = TRUE),
    lo95   = quantile(wtp, 0.025, na.rm = TRUE),
    hi95   = quantile(wtp, 0.975, na.rm = TRUE),
    .groups = "drop"
  )

wtp_pop_summary

```

```{r}
db <- apollo_inputs$database
ids <- unique(db$RID)
length(ids)

```

```{r}
simulate_individual_medians <- function(model_mxl,
                                       ids,
                                       rand_attrs,
                                       sd_names,
                                       cost_name = "b_cost",
                                       n_draws_per_person = 2000) {

  bhat <- model_mxl$estimate

  # Explicit numeric extraction
  mu <- setNames(as.numeric(bhat[rand_attrs]), rand_attrs)
  b_cost <- as.numeric(bhat[cost_name])

  # Map SD names -> attr names safely:
  # assumes sd_names are in same order as rand_attrs
  sd <- setNames(as.numeric(bhat[sd_names]), rand_attrs)

  # Safety checks
  if (any(is.na(mu))) stop("Some rand_attrs missing in estimates: ", paste(rand_attrs[is.na(mu)], collapse=", "))
  if (any(is.na(sd))) stop("Some sd_names missing in estimates.")
  if (is.na(b_cost)) stop("Cost coefficient missing: ", cost_name)

  K <- length(rand_attrs)

  # For speed, do this with map_dfr but each person uses matrices only
  map_dfr(ids, function(id){

    Z <- matrix(rnorm(n_draws_per_person * K), nrow = n_draws_per_person, ncol = K)
    colnames(Z) <- rand_attrs

    beta_mat <- sweep(Z, 2, sd, `*`)
    beta_mat <- sweep(beta_mat, 2, mu, `+`)

    wtp_mat <- -beta_mat / b_cost

    tibble(
      RID = id,
      !!!setNames(as.list(apply(wtp_mat, 2, median, na.rm = TRUE)), rand_attrs)
    )
  })
}


```

```{r}
wtp_ind_medians_wide <- simulate_individual_medians(
  model_mxl = model_mxl,
  ids = ids,
  rand_attrs = rand_attrs,
  sd_names = sd_names,
  cost_name = cost_name,
  n_draws_per_person = 1393
)


```

```{r}
wtp_ind_medians <- wtp_ind_medians_wide %>%
  pivot_longer(-RID, names_to = "Attribute", values_to = "wtp_median")

```

```{r}
wtp_ind_summary <- wtp_ind_medians %>%
  group_by(Attribute) %>%
  summarise(
    median_of_individual_medians = median(wtp_median, na.rm = TRUE),
    mean_of_individual_medians   = mean(wtp_median, na.rm = TRUE),
    lo95 = quantile(wtp_median, 0.025, na.rm = TRUE),
    hi95 = quantile(wtp_median, 0.975, na.rm = TRUE),
    .groups = "drop"
  )

wtp_ind_summary

```

```{r}

ggplot(wtp_pop_draws, aes(x = wtp)) +
  geom_density(alpha = 0.35) +
  facet_wrap(~ Attribute, scales = "free") +
  labs(x = "WTP", y = "Density", title = "Population WTP distribution (MXL simulation)") +
  theme_minimal()

```

```{r}
ggplot(wtp_ind_medians, aes(x = wtp_median)) +
  geom_density(alpha = 0.35) +
  facet_wrap(~ Attribute, scales = "free") +
  labs(x = "Individual median WTP", y = "Density",
       title = "Distribution of individual median WTP (unconditional)") +
  theme_minimal()

```

```{r}

#Extract apollo model result 
est <- model$estimate

#Extract standard error
se <- sqrt(diag(model$robvarcov))

#Create coefficient table 
coef_table <- tibble(
  Parameter = names(est),
  Estimate  = est,
  SE        = se[names(est)]
)

#Add significance stars
coef_table <- coef_table %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )

```

## RUM For Trails (Residents Only)

Here need to make the data into wide format to create the utility functions.

```{r}
#after running Analysis


mlogit_clean_Residents=mlogit_clean_Residents[c(1:11,15,19,38:47, 71)]
mlogit_clean_Residents$Alternative[which(mlogit_clean_Residents$Alternative==1)]="alt1"
mlogit_clean_Residents$Alternative[which(mlogit_clean_Residents$Alternative=="2")]="alt2"
mlogit_clean_Residents$Alternative[which(mlogit_clean_Residents$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_Residents_wide=reshape(mlogit_clean_Residents,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternative’s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_Residents_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)

#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

# Apollo code

b_HHIncome_num = 0,

```{r}

apollo_beta <- c(
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow        = 0,
  b_cost                = 0,
  b_age                 = 0,
  b_education           = 0,
  #b_environment = 0, 
  b_income              = 0, 
  b_sex = 0
)
apollo_fixed <- c()


apollo_inputs<-apollo_validateInputs()
```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1
  V[["alt1"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt1 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt1 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt1 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt1 +
    b_CrowdingMed         * CrowdingM.alt1 +
    b_CrowdingLow         * CrowdingL.alt1 +
    b_cost                * Cost.alt1 +
    
    # person-specific covariates (shift alt1 vs opt-out)
    #b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
   #b_environment* Member.Environment_binary +
    #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Utility for alt2
  V[["alt2"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt2 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt2 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt2 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt2 +
    b_CrowdingMed         * CrowdingM.alt2 +
    b_CrowdingLow         * CrowdingL.alt2 +
    b_cost                * Cost.alt2 +
    
    # person-specific covariates (shift alt2 vs opt-out)
   # b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
    #b_environment* Member.Environment_binary +
   #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
  P[["model"]] = apollo_mnl(mnl_settings, functionality)
  P = apollo_panelProd(P, apollo_inputs, functionality)
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  
  return(P)
}
```

```{r}
model_residents = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

summary(model_residents)
```

```{r}

# Extract Apollo model results
est.residents <- model_residents$estimate

# Extract standard errors
se.residents <- sqrt(diag(model_residents$robvarcov))

# Create coefficient table
coef_residents <- tibble(
  Parameter = names(est.residents),
  Estimate  = est.residents,
  SE        = se.residents[names(est.residents)]
)

# Add significance stars
coef_residents <- coef_residents %>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )

```

## RUM For Trails (Tourists Only)

Here need to make the data into wide format to create the utility functions.

```{r}
#after running Analysis


mlogit_clean_Tourists=mlogit_clean_Tourists[c(1:11,15,19,38:47, 71)]
mlogit_clean_Tourists$Alternative[which(mlogit_clean_Tourists$Alternative==1)]="alt1"
mlogit_clean_Tourists$Alternative[which(mlogit_clean_Tourists$Alternative=="2")]="alt2"
mlogit_clean_Tourists$Alternative[which(mlogit_clean_Tourists$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_Tourists_wide=reshape(mlogit_clean_Tourists,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternative’s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_Tourists_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityL.alt1=0
database$Habitat_QualityL.alt1[which(database$Habitat_Quality.alt1=="Low")]=1
database$Habitat_QualityM.alt1=0
database$Habitat_QualityM.alt1[which(database$Habitat_Quality.alt1=="Medium")]=1
database$Habitat_QualityH.alt1=0
database$Habitat_QualityH.alt1[which(database$Habitat_Quality.alt1=="High")]=1

database$Habitat_QualityL.alt2=0
database$Habitat_QualityL.alt2[which(database$Habitat_Quality.alt2=="Low")]=1
database$Habitat_QualityM.alt2=0
database$Habitat_QualityM.alt2[which(database$Habitat_Quality.alt2=="Medium")]=1
database$Habitat_QualityH.alt2=0
database$Habitat_QualityH.alt2[which(database$Habitat_Quality.alt2=="High")]=1


database$Trail_ConditionL.alt1=0
database$Trail_ConditionL.alt1[which(database$Trail_Condition.alt1=="Low")]=1
database$Trail_ConditionM.alt1=0
database$Trail_ConditionM.alt1[which(database$Trail_Condition.alt1=="Medium")]=1
database$Trail_ConditionH.alt1=0
database$Trail_ConditionH.alt1[which(database$Trail_Condition.alt1=="High")]=1

database$Trail_ConditionL.alt2=0
database$Trail_ConditionL.alt2[which(database$Trail_Condition.alt2=="Low")]=1
database$Trail_ConditionM.alt2=0
database$Trail_ConditionM.alt2[which(database$Trail_Condition.alt2=="Medium")]=1
database$Trail_ConditionH.alt2=0
database$Trail_ConditionH.alt2[which(database$Trail_Condition.alt2=="High")]=1



## Crowding logic is reverse here when crowdings is coded at low it means there is high crowding when it is coded as high it means low crowding so here we reverse so that the one we drop is high crowding and compare what they would pay for medium or Low crowds.

database$CrowdingH.alt1=0
database$CrowdingH.alt1[which(database$Crowding.alt1=="Low")]=1
database$CrowdingM.alt1=0
database$CrowdingM.alt1[which(database$Crowding.alt1=="Medium")]=1
database$CrowdingL.alt1=0
database$CrowdingL.alt1[which(database$Crowding.alt1=="High")]=1



database$CrowdingH.alt2=0
database$CrowdingH.alt2[which(database$Crowding.alt2=="Low")]=1
database$CrowdingM.alt2=0
database$CrowdingM.alt2[which(database$Crowding.alt2=="Medium")]=1
database$CrowdingL.alt2=0
database$CrowdingL.alt2[which(database$Crowding.alt2=="High")]=1



```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1


#Resident 
database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

#Age
database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

#Income 
database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))

#Education 
database$CollegePlus <- ifelse(
  database$Demo_Education.alt1 %in% c(
    "Bachelor's degree",
    "Graduate or professional degree (MA, MS, MBA, PhD, JD, MD, DDS etc.)"
  ),
  1, 0
)


#member of environmental group
database$Member.Environment_binary <- ifelse(database$Member_Env.Group.alt1 == "Yes", 1, 0)
database$WTP_User.fee_binary       <- ifelse(database$User.fee_Y.N.alt1      == "Yes", 1, 0)
database$Sex_binary <- ifelse(database$Demo_Sex.alt1=="Female", 1,
                             ifelse(database$Demo_Sex.alt1=="Male", 0, NA))
database$Sex_binary[is.na(database$Sex_binary)] <- 0   # if you still want to force it

database$Resident                  <- ifelse(database$Zipverified.alt1       == "Resident", 1, 0)


#database=database[c(1,3,4,6,10,11:18,28,46, 55:81)]
colnames(database)[1]="RID"
colnames(database)[4]="choice"

database$choice=as.numeric(
  database$choice
)
database$choice=as.numeric(database$choice)
```

# Apollo code

b_HHIncome_num = 0,

```{r}

apollo_beta <- c(
  b_Habitat_QualityMed  = 0,
  b_Habitat_QualityHigh = 0,
  b_Trail_ConditionMed  = 0,
  b_Trail_ConditionHigh = 0,
  b_CrowdingMed         = 0,
  b_CrowdingLow        = 0,
  b_cost                = 0,
  b_age                 = 0,
  b_education           = 0,
  #b_environment = 0, 
  b_income              = 0, 
  b_sex = 0
)
apollo_fixed <- c()


apollo_inputs<-apollo_validateInputs()
```

```{r}
apollo_probabilities=function(apollo_beta, apollo_inputs, functionality="estimate"){
  
  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))
  
  P = list()
  V = list()
  
  # Utility for alt1
  V[["alt1"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt1 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt1 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt1 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt1 +
    b_CrowdingMed         * CrowdingM.alt1 +
    b_CrowdingLow         * CrowdingL.alt1 +
    b_cost                * Cost.alt1 +
    
    # person-specific covariates (shift alt1 vs opt-out)
    #b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
   #b_environment* Member.Environment_binary +
    #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Utility for alt2
  V[["alt2"]]  =
    b_Habitat_QualityMed  * Habitat_QualityM.alt2 +
    b_Habitat_QualityHigh * Habitat_QualityH.alt2 +
    b_Trail_ConditionMed  * Trail_ConditionM.alt2 +
    b_Trail_ConditionHigh * Trail_ConditionH.alt2 +
    b_CrowdingMed         * CrowdingM.alt2 +
    b_CrowdingLow         * CrowdingL.alt2 +
    b_cost                * Cost.alt2 +
    
    # person-specific covariates (shift alt2 vs opt-out)
   # b_resident   * Resident +
    b_age        * Demo_Age_num +
    b_education  * CollegePlus +
    #b_environment* Member.Environment_binary +
   #b_userfee    * WTP_User.fee_binary +
    b_income     * HHIncome_num +
    b_sex        * Sex_binary
  
  # Opt-out / status quo fixed at 0
  V[["alt3"]] = 0
  
  mnl_settings = list(
    alternatives  = c(alt1=1, alt2=2, alt3=3),
    avail         = list(alt1=1, alt2=1, alt3=1),
    choiceVar     = choice,
    utilities     = V
  )
  
  P[["model"]] = apollo_mnl(mnl_settings, functionality)
  P = apollo_panelProd(P, apollo_inputs, functionality)
  P = apollo_prepareProb(P, apollo_inputs, functionality)
  
  return(P)
}
```

```{r}
model_tourists = apollo_estimate(apollo_beta, apollo_fixed, apollo_probabilities, apollo_inputs)

summary(model_tourists)
```

```{r}

# Extract Apollo model results
est.tourists <- model_tourists$estimate

# Extract standard errors
se.tourists<- sqrt(diag(model_tourists$robvarcov))

# Create coefficient table
coef_tourists <- tibble(
  Parameter = names(est.tourists),
  Estimate  = est.tourists,
  SE        = se.residents[names(est.tourists)]
)

# Add significance stars
coef_tourists <- coef_tourists%>%
  mutate(
    z = Estimate / SE,
    Stars = case_when(
      abs(z) > 3.29 ~ "***",
      abs(z) > 2.58 ~ "**",
      abs(z) > 1.96 ~ "*",
      TRUE ~ ""
    )
  )

```

## **Create Table: Combine output: Stargazer**

```{r}
get_apollo_stargazer_inputs <- function(model, robust = TRUE, p_sided = 2) {
  M <- as.matrix(apollo_modelOutput(model, modelOutput_settings = list(silent = TRUE)))

  b  <- M[, "Estimate"]

  if (robust) {
    se <- M[, "Rob.s.e."]
    t  <- M[, "Rob.t.rat.(0)"]
  } else {
    se <- M[, "s.e."]
    t  <- M[, "t.rat.(0)"]
  }

  # p-values from t-ratio (normal approximation)
  if (p_sided == 1) {
    p <- 1 - pnorm(abs(t))             # 1-sided
  } else {
    p <- 2 * (1 - pnorm(abs(t)))       # 2-sided (typical)
  }

  names(b)  <- rownames(M)
  names(se) <- rownames(M)
  names(p)  <- rownames(M)

  list(b = b, se = se, p = p)
}
```

```{r}
library(stargazer)

# Extract
v_all  <- get_apollo_stargazer_inputs(model,      robust = TRUE, p_sided = 2)
v_res  <- get_apollo_stargazer_inputs(model_residents, robust = TRUE, p_sided = 2)
v_tour <- get_apollo_stargazer_inputs(model_tourists,  robust = TRUE, p_sided = 2)

# Choose your row order (edit if needed)
order <- c(
  "b_Habitat_QualityMed","b_Habitat_QualityHigh",
  "b_Trail_ConditionMed","b_Trail_ConditionHigh",
  "b_CrowdingMed","b_CrowdingLow",
  "b_cost",
  "b_resident",
  "b_age","b_education","b_income","b_sex"
)

# Labels to print (same length/order as 'order')
labels <- c(
  "Habitat quality (Medium)","Habitat quality (High)",
  "Trail condition (Medium)","Trail condition (High)",
  "Crowding (Medium)","Crowding (Low)",
  "Cost",
  "Resident",
  "Age","Education","Income","Sex"
)

# Align each model’s vectors to the same coefficient list
coef_list <- list(
  align_to(v_all$b,  order),
  align_to(v_res$b,  order),
  align_to(v_tour$b, order)
)

se_list <- list(
  align_to(v_all$se,  order),
  align_to(v_res$se,  order),
  align_to(v_tour$se, order)
)

p_list <- list(
  align_to(v_all$p,  order),
  align_to(v_res$p,  order),
  align_to(v_tour$p, order)
)

# Dummy models for stargazer
make_dummy_lm_named <- function(coef_names, n = 100, seed = 1) {
  set.seed(seed)
  K <- length(coef_names)
  X <- as.data.frame(matrix(rnorm(n * K), nrow = n, ncol = K))
  names(X) <- coef_names
  X$y <- rnorm(n)
  lm(y ~ 0 + ., data = X)  # no intercept, so exactly K coefs with these names
}

d1 <- make_dummy_lm_named(order, seed = 1)
d2 <- make_dummy_lm_named(order, seed = 2)
d3 <- make_dummy_lm_named(order, seed = 3)


```

```{r}
align_to <- function(x, order) {
  out <- rep(NA_real_, length(order))
  names(out) <- order
  out[names(x)] <- x
  out
}

coef_list <- list(
  align_to(v_all$b,  order),
  align_to(v_res$b,  order),
  align_to(v_tour$b, order)
)
se_list <- list(
  align_to(v_all$se,  order),
  align_to(v_res$se,  order),
  align_to(v_tour$se, order)
)
p_list <- list(
  align_to(v_all$p,  order),
  align_to(v_res$p,  order),
  align_to(v_tour$p, order)
)
```

```{r}
obs <- c(
  model$nObs,
  model_residents$nObs,
  model_tourists$nObs
)

respondents <- c(
  model$nIndivs,
  model_residents$nIndivs,
  model_tourists$nIndivs
)

aic <- round(c(
  model$AIC,
  model_residents$AIC,
  model_tourists$AIC
), 2)

```

```{r}
stargazer(
  d1, d2, d3,
  type = "latex",
  out  = "mxl_3models.tex",
  title = "Trail Choice Model Results",
  column.labels = c("All Respondents", "Residents only", "Tourists only"),
  dep.var.labels.include = FALSE,
  covariate.labels = labels,
  coef = coef_list,
  se   = se_list,
  p    = p_list,
  digits = 3,
  omit.stat = c("n","f","ser","adj.rsq","rsq"),
  add.lines = list(
    c("Observations", obs),
    c("Respondents", respondents),
    c("AIC", aic)
  ),
  notes = "Robust standard errors in parentheses.",
  notes.append = FALSE
)



```

```{r}
stargazer(
  d1, d2, d3,
  type = "html",
  out  = "mxl_3models.html",
  title = "Trail Choice Model Results",
  column.labels = c("All Respondents", "Residents only", "Tourists only"),
  dep.var.labels.include = FALSE,
  covariate.labels = labels,
  coef = coef_list,
  se   = se_list,
  p    = p_list,
  digits = 3,
  omit.stat = c("n","f","ser","adj.rsq","rsq"),
  add.lines = list(
    c("Observations", obs),
    c("Respondents", respondents),
    c("AIC", aic)
  ),
  notes = "Robust standard errors in parentheses.",
  notes.append = FALSE
)



```

## **Create Table: Combine output**

```{r}
coef_table %<>%
  mutate(
    Variable = dplyr::recode(
      Parameter,
      b_Habitat_QualityMed  = "Habitat quality (Medium)",
      b_Habitat_QualityHigh = "Habitat quality (High)",
      b_Trail_ConditionMed  = "Trail condition (Medium)",
      b_Trail_ConditionHigh = "Trail condition (High)",
      b_CrowdingMed         = "Crowding (Medium)",
      b_CrowdingLow         = "Crowding (Low)",
      b_cost                = "Cost",
      b_resident            = "Resident",
      b_age                 = "Age",
      b_income              = "Income",
      b_sex                 = "Sex"
    )
  ) %>%
  filter(!is.na(Variable)) %>%
  mutate(
    MNL = sprintf("%.3f (%.3f)%s", Estimate, SE, Stars)
  ) %>%
  select(Variable, MNL)

```

## 

```{r}
format_coef <- function(df, col_name) {
  df %>%
    mutate(
      Variable = dplyr::recode(
        Parameter,
        b_Habitat_QualityMed  = "Habitat quality (Medium)",
        b_Habitat_QualityHigh = "Habitat quality (High)",
        b_Trail_ConditionMed  = "Trail condition (Medium)",
        b_Trail_ConditionHigh = "Trail condition (High)",
        b_CrowdingMed         = "Crowding (Medium)",
        b_CrowdingLow         = "Crowding (Low)",
        b_cost                = "Cost",
        b_age                 = "Age",
        b_income              = "Income",
        b_sex                 = "Sex"
      ),
      !!col_name := sprintf("%.3f (%.3f)%s", Estimate, SE, Stars)
    ) %>%
    filter(!is.na(Variable)) %>%
    select(Variable, !!col_name)
}

```

```{r}
coef_residents <- format_coef(coef_residents ,  "Residents only")
coef_tourists <- format_coef(coef_tourists, "Tourists only")

```

```{r}
coef_table_final <- coef_table%>%
  left_join(coef_residents,  by = "Variable") %>%
  left_join(coef_tourists, by = "Variable")

```

```{r}
coef_table_final %>%
  gt() %>%
  tab_header(
    title = "Multinomial Logit Model Results",
    subtitle = "Comparison of preferences across residents and tourists"
  ) %>%
  cols_align(
    align = "center",
    columns = -Variable
  ) %>%
  tab_spanner(
    label = "MNL Coefficients (SE)",
    columns = c("MNL", "Residents only", "Tourists only")
  )

coef_table_final %>%
  gt() %>%
  tab_source_note(
    source_note = md(
      "*Notes:* Entries are coefficient estimates with standard errors in parentheses.  
       *, **, *** denote significance at the 10%, 5%, and 1% levels."
    )
  )

coef_table_final %<>%
  rename(`All Respondents` = MNL)


print(coef_table_final)

```

```{r}
coef_table_gt <- coef_table_final %>%
  gt()
gtsave(
  coef_table_gt,
  filename = "Table_MNL_Residents_vs_Tourists.png"
)

```

# WTP table

```{r}
extract_coef <- function(x) as.numeric(str_extract(x, "^-?[0-9.]+"))
extract_se   <- function(x) as.numeric(str_extract(x, "\\(([^)]+)\\)"))


```

```{r}
cost_vals <- coef_table_final %>%
  filter(Variable == "Cost") %>%
  transmute(
    cost_all    = extract_coef(`All Respondents`),
   # se_all      = extract_se(`All Respondents`),

    cost_res    = extract_coef(`Residents only`),
    #se_res      = extract_se(`Residents only`),

    cost_tour   = extract_coef(`Tourists only`),
  #  se_tour     = extract_se(`Tourists only`)
  )


```

```{r}
wtp_table_all <- coef_table_final %>%
  filter(!Variable %in% c("Cost", "Resident", "Age", "Income", "Sex")) %>%
  mutate(
    beta_all = extract_coef(`All Respondents`),
    #se_all   = extract_se(`All Respondents`),

 WTP = -beta_all / cost_vals$cost_all,
  WTP = signif(WTP, 3)
  ) %>%
  select(Variable, `All Respondents WTP (USD)` = WTP)


   # WTP_SE = abs(WTP) * sqrt(
      #(se_all / beta_all)^2 +
      #(cost_vals$se_all / cost_vals$cost_all)^2
    #),

    #WTP_Low  = WTP - 1.96 * WTP_SE,
    #WTP_High = WTP + 1.96 * WTP_SE
  #)


```

```{r}
wtp_table_resident <- coef_table_final %>%
  filter(!Variable %in% c("Cost", "Resident", "Age", "Income", "Sex")) %>%
  mutate(
    beta_resident = extract_coef(`Residents only`),
    #se_all   = extract_se(`All Respondents`),
    

    WTP = - beta_resident / cost_vals$cost_res,
        WTP = -beta_resident / cost_vals$cost_res,
   WTP = signif(WTP, 3)
  ) %>%
  select(Variable, `Resident WTP (USD)` = WTP)
```

```{r}
wtp_table_tourist<- coef_table_final %>%
  filter(!Variable %in% c("Cost", "Resident", "Age", "Income", "Sex")) %>%
  mutate(
    beta_tourist = extract_coef(`Tourists only`),
    #se_all   = extract_se(`All Respondents`),

    WTP. = -  beta_tourist / cost_vals$cost_tour, 
            WTP = -beta_tourist / cost_vals$cost_tour,
   WTP = signif(WTP, 3)
  ) %>%
  select(Variable, `Tourist WTP (USD)` = WTP)
```

```{r}
wtp_table_final <- wtp_table_all%>%
  left_join(wtp_table_resident,  by = "Variable") %>%
  left_join(wtp_table_tourist, by = "Variable")
```

```{r}
wtp_table_gt <- wtp_table_final  %>%
  gt()
gtsave(
  wtp_table_gt,
  filename = "Table_WTP_Residents_vs_Tourists.png"
)
```

# WTP distrubution

```{r}
extract_beta <- function(x) as.numeric(str_extract(x, "^-?\\d*\\.?\\d+"))
extract_se   <- function(x) as.numeric(str_match(x, "\\(([^)]+)\\)")[,2])
```

```{r}
coef_long <- coef_table_final %>%
  pivot_longer(
    cols = c(`All Respondents`, `Residents only`, `Tourists only`),
    names_to = "group",
    values_to = "cell"
  ) %>%
  mutate(
    beta = extract_beta(cell),
    se   = extract_se(cell)
  ) %>%
  select(Variable, group, beta, se)
```

```{r}
cost_by_group <- coef_long %>%
  filter(Variable == "Cost") %>%
  transmute(group, cost_beta = beta, cost_se = se)

coef_w_cost <- coef_long %>%
  left_join(cost_by_group, by = "group")

```

```{r}
wtp_delta <- function(beta, beta_se, cost, cost_se) {
  wtp <- -beta / cost
  var_wtp <- (1 / cost)^2 * beta_se^2 +
             (beta / cost^2)^2 * cost_se^2
  tibble(mean_wtp = wtp, se_wtp = sqrt(var_wtp))
}

# wtp_table <- coef_w_cost %>%
#   filter(!Variable %in% c("Cost", "Resident", "Age", "b_education", "Income", "Sex")) %>%
#   mutate(tmp = pmap(list(beta, se, cost_beta, cost_se), wtp_delta)) %>%
#   unnest(tmp) %>%
#   select(Attribute = Variable, group, mean_wtp, se_wtp) %>%
#   arrange(Attribute, group)

```

```{r}
simulate_wtp <- function(beta, beta_se, cost, cost_se, n = 10000) {
  b_draw <- rnorm(n, beta, beta_se)
  c_draw <- rnorm(n, cost, cost_se)

  # optional: drop draws where cost flips sign (helps avoid crazy ratios)
  c_draw[c_draw >= 0] <- NA_real_

  tibble(wtp = -b_draw / c_draw)
}


```

```{r}
wtp_draws <- coef_w_cost %>%
  filter(!Variable %in% c("Cost", "Resident", "Age", "b_education", "Income", "Sex")) %>%
  mutate(draws = pmap(
    list(beta, se, cost_beta, cost_se),
    ~ simulate_wtp(..1, ..2, ..3, ..4, n = 10000)
  )) %>%
  unnest(draws) %>%
  rename(Attribute = Variable) %>%
  filter(is.finite(wtp))

```

```{r}
plot_one_attribute <- function(attr_name) {

  df <- dplyr::filter(wtp_draws, Attribute == attr_name)

  medians <- df %>%
    dplyr::group_by(group) %>%
    dplyr::summarise(med_wtp = median(wtp, na.rm = TRUE), .groups = "drop")

  ggplot(df, aes(x = wtp, fill = group)) +
    geom_density(alpha = 0.35, na.rm = TRUE) +
    geom_vline(
      data = medians,
      aes(xintercept = med_wtp, color = group),
      linetype = "dashed",
      linewidth = 0.8
    ) +
    coord_cartesian(xlim = c(0, 200)) +
    labs(
      title = attr_name,
      x = "WTP",
      y = "Density"
    ) +
    theme_minimal() +
    guides(color = "none")   # keeps legend clean
}


plot_one_attribute("Habitat quality (High)")



```

```{r}
wtp_hab_high_all <- simulate_wtp(
  beta     = 0.645,
  beta_se  = 0.055,
  cost     = -0.008,
  cost_se  = 0.001
)

```

```{r}
wtp_hab_high_all %>%
  summarise(
    mean   = mean(wtp, na.rm = TRUE),
    median = median(wtp, na.rm = TRUE),
    p10    = quantile(wtp, 0.10, na.rm = TRUE),
    p90    = quantile(wtp, 0.90, na.rm = TRUE)
  )

```

```{r}

ggplot(wtp_hab_high_all, aes(x = wtp)) +
  geom_density(fill = "steelblue", alpha = 0.4) +
  geom_vline(xintercept = median(wtp_hab_high_all$wtp, na.rm = TRUE),
             linetype = "dashed") +
  labs(
    x = "WTP ($)",
    y = "Density",
    title = "Simulated distribution of mean WTP\nHabitat Quality (High)"
  ) +
  theme_minimal()

```
