---
title: "index"
format: html
editor: visual
---

## RUM For Trails

Here need to make the data into wide format to create the utility functions.

```{r}
### Initialise code
apollo_control <- list(
  modelName  = "LC_Trails_FullLC_Demo_2class",
  modelDescr = "Full latent class with demographics in class membership",
  indivID    = "RID",
  panelData  = TRUE,
  nCores     = 8
)



```

```{r}
#after running Analysis


mlogit_clean=mlogit_clean[c(1:11,15,19,40:47, 71)]
mlogit_clean$Alternative[which(mlogit_clean$Alternative==1)]="alt1"
mlogit_clean$Alternative[which(mlogit_clean$Alternative=="2")]="alt2"
mlogit_clean$Alternative[which(mlogit_clean$Alternative=="3")]="alt3"
#mlogit_clean$Choice.Binary=NULL
#Note design_ngene still says 50
# mlogit_clean$Cost[which(mlogit_clean$Cost==50)]=40
mlogit_clean_wide=reshape(mlogit_clean,timevar = "Alternative",
idvar = c(1:3,5,7),
direction = "wide" ) # Each respondent-choice task becomes one row, with separate columns for each alternativeâ€™s attributes.

apollo_control <- list(
  modelName  = "Trail_Choice",
  modelDescr = "Simple MNL model with trail alternatives",
  indivID    = "RID" ,
  panelData = TRUE
)
database=mlogit_clean_wide

```

To expand we will create for each alternative there is a low, medium, high for each alternative 1 and 2 . Alternative 3 is all zeros so we can deal with that in the utility function.

```{r}
database$Habitat_QualityM.alt1 <- ifelse(as.character(database$Habitat_Quality.alt1) == "Medium", 1, 0)
database$Habitat_QualityH.alt1 <- ifelse(as.character(database$Habitat_Quality.alt1) == "High",   1, 0)

database$Habitat_QualityM.alt2 <- ifelse(as.character(database$Habitat_Quality.alt2) == "Medium", 1, 0)
database$Habitat_QualityH.alt2 <- ifelse(as.character(database$Habitat_Quality.alt2) == "High",   1, 0)


database$Trail_ConditionM.alt1 <- ifelse(as.character(database$Trail_Condition.alt1) == "Medium", 1, 0)
database$Trail_ConditionH.alt1 <- ifelse(as.character(database$Trail_Condition.alt1) == "High",   1, 0)
database$Trail_ConditionM.alt2 <- ifelse(as.character(database$Trail_Condition.alt2) == "Medium", 1, 0)
database$Trail_ConditionH.alt2 <- ifelse(as.character(database$Trail_Condition.alt2) == "High",   1, 0)

database$CrowdingM.alt1 <- ifelse(as.character(database$Crowding.alt1) == "Medium", 1, 0)
database$CrowdingL.alt1 <- ifelse(as.character(database$Crowding.alt1) == "High",   1, 0)

database$CrowdingM.alt2 <- ifelse(as.character(database$Crowding.alt2) == "Medium", 1, 0)
database$CrowdingL.alt2 <- ifelse(as.character(database$Crowding.alt2) == "High",   1, 0)


```

Need to create some demographic info to control in the regression.

```{r}
database$Choice.Task.alt1



database <- database %>% mutate( viewpoint = if_else(as.numeric(Choice.Task.alt2) %%2 == 0,1,0))
database$Resident=0
database$Resident[which(database$Zipverified.alt1=="Resident")]=1

database$Demo_Age_num=as.integer(factor(
    database$Demo_Age.alt1,
    levels = c(
        "Under 18",
        "18-24 years old",
        "25-34 years old",
        "35-44 years old",
        "45-54 years old",
        "55-64 years old",
        "65+ years old"
    ),
    labels = 1:7
))

database$HHIncome_num <- as.integer(factor(
  database$Demo_HH.Income.alt1,
  levels = c(
    "Less than $25,000",
    "$25,000 -$49,999",
    "$50,000 -$74,999",
    "$75,000 -$99,999",
    "$100,000 -$149,999",
    "$150,000 or more"
  ),
  labels = 1:6
))


database$Sex_binary <- ifelse(database$Demo_Sex.alt1 == "Female", 1,
                             ifelse(database$Demo_Sex.alt1 == "Male", 0, 0))


database$Resident <- ifelse(database$Zipverified.alt1 == "Resident", 1, 0)




```

```{r}

# Make sure these exist and are numeric
vars <- c("Resident", "Demo_Age_num", "HHIncome_num", "Sex_binary")
sapply(database[vars], class)

# Check for NA / Inf
sapply(database[vars], function(x) sum(!is.finite(x)))
sapply(database[vars], function(x) sum(is.na(x)))

# Quick summaries
summary(database[vars])

table(database$HHIncome_num, useNA="ifany")




```

```{r}
# --- 1) Create RID robustly (pick any RID.alt* column that exists) ---
rid_cols <- names(database)[grepl("^RID\\.alt", names(database))]
stopifnot(length(rid_cols) > 0)
database$RID <- database[[rid_cols[1]]]

# --- 2) Create choice robustly (pick an existing Chosen.Alternative.alt* column) ---
chosen_cols <- names(database)[grepl("^Chosen\\.Alternative\\.alt", names(database))]
stopifnot(length(chosen_cols) > 0)

# Use alt2 if available (in your case it is)
use_col <- if ("Chosen.Alternative.alt2" %in% chosen_cols) "Chosen.Alternative.alt2" else chosen_cols[1]
database$choice <- as.numeric(as.character(database[[use_col]]))

# --- 3) Final checks ---
stopifnot("RID" %in% names(database))
stopifnot("choice" %in% names(database))
table(database$choice, useNA="ifany")

```

# Apollo code

b_HHIncome_num = 0,

```{r}
apollo_beta <- c(
  # Class 1 tastes
  b_Habitat_QualityMed_1    = 0.34,
  b_Habitat_QualityHigh_1   = 0.65,
  b_Trail_ConditionMed_1    = 0.43,
  b_Trail_ConditionHigh_1   = 0.62,
  b_CrowdingMed_1           = 0.31,
  b_CrowdingLow_1           = 0.36,
  b_cost_1                  = -0.008,

  # Class 2 (ANA: only cost)
  b_cost_2                  = -0.020,

  # Class membership intercept
  delta_2                   = -1,

  # Demographics in class membership
  gamma_resident_2          = 0,
  gamma_age_2               = 0,
  gamma_income_2            = 0,
  gamma_sex_2               = 0
)

apollo_fixed <- c()


```

```{r}
### Latent class definition (create ANA)
apollo_lcPars <- function(apollo_beta, apollo_inputs){

  lcpars = list()

  # Confirmatory ANA
  lcpars[["b_Habitat_QualityMed"]]  = list(b_Habitat_QualityMed_1,  0)
  lcpars[["b_Habitat_QualityHigh"]] = list(b_Habitat_QualityHigh_1, 0)
  lcpars[["b_Trail_ConditionMed"]]  = list(b_Trail_ConditionMed_1,  0)
  lcpars[["b_Trail_ConditionHigh"]] = list(b_Trail_ConditionHigh_1, 0)
  lcpars[["b_CrowdingMed"]]         = list(b_CrowdingMed_1,         0)
  lcpars[["b_CrowdingLow"]]         = list(b_CrowdingLow_1,         0)
  lcpars[["b_cost"]]                = list(b_cost_1, b_cost_2)

  # Class membership utilities
  V = list()
  V[["class1"]] = 0
  V[["class2"]] =
    delta_2 +
    gamma_resident_2 * Resident +
    gamma_age_2      * Demo_Age_num +
    gamma_income_2   * HHIncome_num +
    gamma_sex_2      * Sex_binary

  lcpars[["pi_values"]] =
    apollo_classAlloc(
      list(
        classes   = c(class1=1, class2=2),
        utilities = V
      )
    )

  return(lcpars)
}

```

```{r}
### Utility Function 
apollo_probabilities <- function(apollo_beta, apollo_inputs, functionality="estimate"){

  apollo_attach(apollo_beta, apollo_inputs)
  on.exit(apollo_detach(apollo_beta, apollo_inputs))

  P <- list()

  # --- Within-class probabilities at the ROW level ---
  for(s in 1:2){

    V <- list()

    V[["alt1"]] <-
      b_Habitat_QualityMed[[s]]  * Habitat_QualityM.alt1 +
      b_Habitat_QualityHigh[[s]] * Habitat_QualityH.alt1 +
      b_Trail_ConditionMed[[s]]  * Trail_ConditionM.alt1 +
      b_Trail_ConditionHigh[[s]] * Trail_ConditionH.alt1 +
      b_CrowdingMed[[s]]         * CrowdingM.alt1 +
      b_CrowdingLow[[s]]         * CrowdingL.alt1 +
      b_cost[[s]]                * Cost.alt1

    V[["alt2"]] <-
      b_Habitat_QualityMed[[s]]  * Habitat_QualityM.alt2 +
      b_Habitat_QualityHigh[[s]] * Habitat_QualityH.alt2 +
      b_Trail_ConditionMed[[s]]  * Trail_ConditionM.alt2 +
      b_Trail_ConditionHigh[[s]] * Trail_ConditionH.alt2 +
      b_CrowdingMed[[s]]         * CrowdingM.alt2 +
      b_CrowdingLow[[s]]         * CrowdingL.alt2 +
      b_cost[[s]]                * Cost.alt2

    V[["alt3"]] <- 0

    mnl_settings <- list(
      alternatives  = c(alt1=1, alt2=2, alt3=3),
      avail         = list(alt1=1, alt2=1, alt3=1),
      choiceVar     = choice,
      utilities     = V,
      componentName = paste0("Class_", s)
    )

    P[[paste0("Class_", s)]] <- apollo_mnl(mnl_settings, functionality)
  }

  # --- Mix classes at ROW level ---
  P[["model"]] <- apollo_lc(
    list(inClassProb = P, classProb = pi_values),
    apollo_inputs,
    functionality
  )

  # --- NOW take panel product ONCE (individual level) ---
  P <- apollo_panelProd(P, apollo_inputs, functionality)

  P <- apollo_prepareProb(P, apollo_inputs, functionality)
  return(P)
}

```

```{r}
### set dataset

# Create required columns
database$RID    <- database$RID.alt1
database$choice <- as.numeric(database$choice)

# Final checks
exists("database")
"RID" %in% names(database)
"choice" %in% names(database)





```

```{r}
# Validate
apollo_inputs <- apollo_validateInputs()
```

```{r}

model <- apollo_estimate(
  apollo_beta,
  apollo_fixed,
  apollo_probabilities,
  apollo_inputs
)

apollo_modelOutput(model)

```

```{r}
apollo_saveOutput(model)
```

```{r}
est <- data.frame(
  term = names(model$estimate),
  estimate = as.numeric(model$estimate)
)

# If robust SE exists, include it
if(!is.null(model$robse)){
  est$rob_se <- model$robse
  est$rob_t  <- est$estimate / est$rob_se
}

write.csv(est, "LC_ANA_coefficients.csv", row.names = FALSE)

```
